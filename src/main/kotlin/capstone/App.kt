/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package capstone

import io.ktor.application.*
import io.ktor.http.*
import io.ktor.response.*
import io.ktor.routing.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*

import io.ktor.websocket.*
import io.ktor.http.cio.websocket.*
import io.ktor.http.cio.websocket.CloseReason
import io.ktor.http.cio.websocket.Frame

import kotlinx.coroutines.channels.*

import java.io.File

class App {
    val greeting: String
        get() {
            return "Hello world."
        }
}

var uuid = 0;

class User(uuid: Int, outgoing: SendChannel<Frame>) {
	var m_uuid: Int;
	var m_outgoing: SendChannel<Frame>;
	var m_x: Double = 0.0;
	var m_y: Double = 0.0;

	init {
		this.m_uuid = uuid;
		this.m_outgoing = outgoing;
	}
}

val users = HashMap<Int, User>();

/*
 -- This function gives errors about co-routines --
fun broadcast(data: String) {
	println("sending: " + data);
	for((key, value) in users) {
		try {
		value.m_outgoing.send(Frame.Text(data));
		} catch (t : Throwable) {

		}
	}
}
*/


fun main() {
	val server = embeddedServer(Netty, port = 25565) {
	
		install(WebSockets);

		routing {

			get("/") {
				val file = File("web/index.html");
				call.respondText(file.readText(), ContentType.Text.Html);
			}

			get("/main.js") {
				val file = File("web/main.js");
				call.respondText(file.readText(), ContentType.Text.Plain);
			}

			webSocket("/") {
				var t_uuid = uuid;
				uuid += 1;
				var user = User(t_uuid, outgoing);
				users.put(t_uuid, user);
				try {
						while(true) {
							val frame = incoming.receive()
							when(frame) {
								is Frame.Text -> {
									val text = frame.readText();
									println("Receive: " + text + " from " + t_uuid.toString());
									if(text == "ping") {
									} else if(text == "hello") {
										//println("Send: welcome");
										outgoing.send(Frame.Text("uuid@$t_uuid"));
									} else if(text == "right") {
										user.m_x += 1.0;
											for((key, value) in users) {
												value.m_outgoing.send(Frame.Text("player@$t_uuid@${user.m_x}@${user.m_y}"));
											}
									} else if(text == "left") {
										user.m_x -= 1.0;
											for((key, value) in users) {
												value.m_outgoing.send(Frame.Text("player@$t_uuid@${user.m_x}@${user.m_y}"));
											}
									} else if(text == "up") {
										user.m_y -= 1.0;
											for((key, value) in users) {
												value.m_outgoing.send(Frame.Text("player@$t_uuid@${user.m_x}@${user.m_y}"));
											}
									} else if(text == "down") {
										user.m_y += 1.0;
											for((key, value) in users) {
												value.m_outgoing.send(Frame.Text("player@$t_uuid@${user.m_x}@${user.m_y}"));
											}
									}
								}
							}
						}
				} catch (e: ClosedReceiveChannelException) {
					println("onClose ${closeReason.await()}");
					users.remove(t_uuid);
					for((key, value) in users) {
						value.m_outgoing.send(Frame.Text("disconnect@$t_uuid"));
					}
				}
			}
		}
	}

	server.start(wait = true);
}
