/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package capstone

import io.ktor.application.*
import io.ktor.http.*
import io.ktor.response.*
import io.ktor.routing.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*

import io.ktor.websocket.*
import io.ktor.http.cio.websocket.*
import io.ktor.http.cio.websocket.CloseReason
import io.ktor.http.cio.websocket.Frame

import kotlinx.coroutines.channels.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.GlobalScope

import java.io.File

class App {
	val greeting: String
		get() {
			return "Hello world."
		}
}

abstract class Rectangle(){
	var m_posX: Double = 0.0
	var m_posY: Double = 0.0
	var m_width: Double = 0.0
	var m_height: Double = 0.0

	fun collides(rect: Rectangle): Boolean {
		return (this.m_posX < rect.m_posX + rect.m_width
				&& this.m_posX + this.m_width > rect.m_posX
				&& this.m_posY < rect.m_posY + rect.m_height
				&& this.m_posY + this.m_height > rect.m_posY)
	}
}

class Block(posX: Double, posY: Double, width: Double, height: Double, delete: Boolean, id: Int): Rectangle(){
	var m_delete : Boolean
	var m_id : Int

	init {
		this.m_posX = posX
		this.m_posY = posY
		this.m_width = width
		this.m_height = height
		this.m_delete = delete
		this.m_id = id
	}
}

class Ball(posX: Double, posY: Double, width: Double, height: Double, id: Int, moveX: Double, moveY: Double): Rectangle(){
    var m_id: Int
    var m_moveX: Double
    var m_moveY: Double

    init{
        this.m_posX = posX
        this.m_posY = posY
        this.m_width = width
        this.m_height = height
        this.m_id = id
        this.m_moveX = moveX
        this.m_moveY = moveY
    }

    fun update() {
        m_posX += m_moveX;
	m_posY += m_moveY;

	if(m_posX < 0) {
		m_moveX = 1.0;
	} else if(m_posX > 720) {
		m_moveX = -1.0;
	}

	if(m_posY < 0) {
		m_moveY = 1.0;
	} else if(m_posY > 480) {
		m_moveY = -1.0;
	}
    }
}

var uuid = 0

class User(uuid: Int, outgoing: SendChannel<Frame>): Rectangle(){
	var m_uuid: Int
	var m_outgoing: SendChannel<Frame>

	init {
		this.m_posX = 20.0
		this.m_posY = 200.0
		this.m_height = 80.0
		this.m_width = 20.0
		this.m_uuid = uuid
		this.m_outgoing = outgoing
	}

}

val users = HashMap<Int, User>()

val spectators = HashMap<Int, User>()

val blocks: MutableList<Block> = mutableListOf()

val balls: MutableList<Ball> = mutableListOf()

/*
 -- This function gives errors about co-routines --
 */
suspend fun broadcast(data: String) {
	println("Sending: " + data)
	for((key, value) in users) {
		try {
			value.m_outgoing.send(Frame.Text(data))
		} catch (t : Throwable) {

		}
	}
	for((key, value) in spectators) {
		try {
			value.m_outgoing.send(Frame.Text(data))
		} catch (t : Throwable) {

		}
	}
}

suspend fun checkCollision() {

	val removeBlocks: MutableList<Block> = mutableListOf()

	for((key, value) in users) {
		for(block in blocks) {
			if(value.collides(block)) {
				removeBlocks.add(block)
				//block.m_delete = true
			}
		}
	}

	for(block in removeBlocks) {
		blocks.remove(block)
		broadcast("delbox@${block.m_id}")
	}
}

suspend fun broadcastPlayers(){
	for((key, value)in users){
		broadcast("player@$key@${value.m_posX}@${value.m_posY}")
	}
}


fun main() {

	for(i in 1..5) {
		var block = Block((i * 25).toDouble(), (i * 25).toDouble(), 10.0, 10.0, false, i)
		blocks.add(block)
	}

    	balls.add(Ball(480.0/2.0, 200.0, 20.0, 20.0, 6, 0.0, -2.0))

	val server = embeddedServer(Netty, port = 25565) {

		install(WebSockets)

		routing {

			get("/") {
				val file = File("web/index.html")
				call.respondText(file.readText(), ContentType.Text.Html)
			}

			get("/main.js") {
				val file = File("web/main.js")
				call.respondText(file.readText(), ContentType.Text.Plain)
			}

			webSocket("/") {
				var t_uuid = uuid
				var isSpectator = false
				uuid += 1
				var user = User(t_uuid, outgoing)
				if(users.size <2) {
					users.put(t_uuid, user)
					if (users.size == 1){
						if (users[0]!!.m_posX < 360.0) {
							user.m_posX = 700.0 - user.m_width
						}
					}
				}
				else{
					spectators.put(t_uuid, user)
					isSpectator = true
				}

				var blockIndex = 0
				for (block in blocks) {
					outgoing.send(Frame.Text("mkbox@${block.m_id}@${block.m_width}@${block.m_height}@${block.m_posX}@${block.m_posY}"))
					++blockIndex
				}

				for(ball in balls) {
					outgoing.send(Frame.Text("mkbox@${ball.m_id}@${ball.m_width}@${ball.m_height}@${ball.m_posX}@${ball.m_posY}"))
				}
				try {
					while (true) {
						val frame = incoming.receive()
						if(isSpectator){
							continue
						}
						when (frame) {
							is Frame.Text -> {
								val text = frame.readText()
								println("Receive: " + text + " from " + t_uuid.toString())
								if (text == "ping") {
								} else if (text == "hello") {
									//println("Send: welcome")
									broadcastPlayers()
									outgoing.send(Frame.Text("uuid@$t_uuid"))
								} else if (text == "right") {
									user.m_posX += 1.0
									broadcast("player@$t_uuid@${user.m_posX}@${user.m_posY}")
									checkCollision()
								} else if (text == "left") {
									user.m_posX -= 1.0
									broadcast("player@$t_uuid@${user.m_posX}@${user.m_posY}")
									checkCollision()
								} else if (text == "up") {
									user.m_posY -= 1.0
									broadcast("player@$t_uuid@${user.m_posX}@${user.m_posY}")
									checkCollision()
								} else if (text == "down") {
									user.m_posY += 1.0
									broadcast("player@$t_uuid@${user.m_posX}@${user.m_posY}")
									checkCollision()
								}
							}
						}
					}
				} catch (e: ClosedReceiveChannelException) {
					println("onClose ${closeReason.await()}")
					users.remove(t_uuid)
					broadcast("disconnect@$t_uuid@${user.m_posX}@${user.m_posY}")
				}

			}
	}
	}


	server.start(wait = false)

	GlobalScope.launch {
		while(true) {
		Thread.sleep(1000/60)
			for(ball in balls) {
				ball.update();	
				broadcast("mvbox@${ball.m_id}@${ball.m_posX}@${ball.m_posY}");
			}
		}
	}
}

