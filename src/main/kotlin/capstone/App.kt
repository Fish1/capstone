/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package capstone

import io.ktor.application.*
import io.ktor.http.*
import io.ktor.response.*
import io.ktor.routing.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*

import io.ktor.websocket.*
import io.ktor.http.cio.websocket.*
import io.ktor.http.cio.websocket.CloseReason
import io.ktor.http.cio.websocket.Frame

import kotlinx.coroutines.channels.*

import java.io.File

class App {
    val greeting: String
        get() {
            return "Hello world."
        }
}

data class Block(val m_posX: Double, val m_posY: Double, val m_width: Double, val m_height: Double);

var uuid = 0;

class User(uuid: Int, outgoing: SendChannel<Frame>) {
	var m_uuid: Int;
	var m_outgoing: SendChannel<Frame>;
	var m_x: Double = 0.0;
	var m_y: Double = 0.0;

	init {
		this.m_uuid = uuid;
		this.m_outgoing = outgoing;
	}
}

val users = HashMap<Int, User>();

val blocks: MutableList<Block> = mutableListOf();

/*
 -- This function gives errors about co-routines --
 */
suspend fun broadcast(data: String) {
	println("Sending: " + data);
	for((key, value) in users) {
		try {
		value.m_outgoing.send(Frame.Text(data));
		} catch (t : Throwable) {

		}
	}
}


fun main() {

	for(i in 1..5) {
		var block = Block((i * 25).toDouble(), (i * 25).toDouble(), 10.0, 10.0);
		blocks.add(block);
	}

	val server = embeddedServer(Netty, port = 25565) {
	
		install(WebSockets);

		routing {

			get("/") {
				val file = File("web/index.html");
				call.respondText(file.readText(), ContentType.Text.Html);
			}

			get("/main.js") {
				val file = File("web/main.js");
				call.respondText(file.readText(), ContentType.Text.Plain);
			}

			webSocket("/") {
				var t_uuid = uuid;
				uuid += 1;
				var user = User(t_uuid, outgoing);
				users.put(t_uuid, user);

				var blockIndex = 0;
				for(block in blocks) {
					outgoing.send(Frame.Text("mkbox@${blockIndex}@${block.m_width}@${block.m_height}@${block.m_posX}@${block.m_posY}"));
					++blockIndex;
				}
				
				try {
					while(true) {
						val frame = incoming.receive()
						when(frame) {
							is Frame.Text -> {
								val text = frame.readText();
								println("Receive: " + text + " from " + t_uuid.toString());
								if(text == "ping") {
								} else if(text == "hello") {
									//println("Send: welcome");
									outgoing.send(Frame.Text("uuid@$t_uuid"));
								} else if(text == "right") {
									user.m_x += 1.0;
									broadcast("player@$t_uuid@${user.m_x}@${user.m_y}");
								} else if(text == "left") {
									user.m_x -= 1.0;
									broadcast("player@$t_uuid@${user.m_x}@${user.m_y}");
								} else if(text == "up") {
									user.m_y -= 1.0;
									broadcast("player@$t_uuid@${user.m_x}@${user.m_y}");
								} else if(text == "down") {
									user.m_y += 1.0;
									broadcast("player@$t_uuid@${user.m_x}@${user.m_y}");
								}
							}
						}
					}
				} catch (e: ClosedReceiveChannelException) {
					println("onClose ${closeReason.await()}");
					users.remove(t_uuid);
					broadcast("player@$t_uuid@${user.m_x}@${user.m_y}");
				}
			}
		}
	}

	server.start(wait = true);
}
